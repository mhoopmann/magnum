/*
Copyright 2021, Michael R. Hoopmann, Institute for Systems Biology

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "MParams.h"

using namespace std;

//==============================
//  Constructors & Destructors
//==============================
MParams::MParams(){
  log = NULL;
  params = NULL;
}

MParams::MParams(mParams* p){
  params = p;
}

MParams::~MParams(){
  log = NULL;
  params = NULL;
}

//==============================
//  Public Functions
//==============================
bool MParams::parseConfig(const char* fname){
  FILE* f;
  char str[512];

  if(params==NULL){
    printf("mParams structure not set in MParams object. No parameters read.\n");
    return false;
  }

  f=fopen(fname,"rt");
  if(f==NULL){
    if (log != NULL) log->addError("Cannot open config file!");
    else printf("Cannot open config file!\n");
    return false;
  }

  while(!feof(f)) {
    if(!fgets(str,512,f)) continue;
    if (strlen(str) == 0) continue;
    if(str[0]=='#') continue;
    if (strlen(str)>4096) {
      if (log != NULL) log->addError("Parameter line too long!");
      else printf("Parameter line too long!\n");
      return false;
    }
    parse(str);
  }

  fclose(f);
  return true;
}

//==============================
//  Private Functions
//==============================
bool MParams::buildOutput(string in, string base, string ext){
  char cwd[1024];
  char str[1024];
  char outPath[1024];
  string tmp;
  string outFile;
  size_t i;
  FILE* f;

  //get current working directory and process input file
  trimPath(base,tmp,params->msBase);
  params->msFile=in;
  params->ext=ext;
  char* b=getcwd(cwd, 1024);
  processPath(cwd, in.c_str(), str);
  params->inFile=str;
  params->inFileNoExt = params->inFile.substr(0,params->inFile.size()-ext.size());

  //expand DB file to full path - only do this once
  if(params->dbPath.empty()){
    processPath(cwd,params->dbFile.c_str(),str);
    params->dbPath=str;
  }
  
  //process output file
  //if user did not specify output path, use cwd as full path for output
  if (params->resPath.empty()){
    processPath(cwd, base.c_str(), outPath);  
  } else {
    if(params->resPath[0]=='.'){
      processPath(cwd, params->resPath.c_str(), outPath);
      tmp = outPath;
    } else {
      tmp = params->resPath;
    }
    outFile = base;
    i = outFile.find_last_of("/\\");
    if (i != string::npos) outFile = outFile.substr(i + 1);
    processPath(&tmp[0], &outFile[0], outPath);
  }
  params->outFile=outPath;

  //Create Magnum output file to test output paths
  sprintf(str, "%s.magnum.txt", params->outFile.c_str());
  f = fopen(str, "wt");
  if (f == NULL) {
    if (log != NULL) log->addError("\nERROR: cannot open " + string(str) + " for output. Please ensure path and write permissions are correct.");
    else cout << "\nERROR: cannot open " << str << " for output. Please ensure path and write permissions are correct." << endl;
    return false;
  } else {
    fclose(f);
  }

  //Create Magnum log file
  sprintf(str, "%s.log", params->outFile.c_str());
  f = fopen(str, "wt");
  if (f == NULL) {
    if (log != NULL) log->addError("\nERROR: cannot open " + string(str) + " to log Magnum. Please ensure path and write permissions are correct.");
    else cout << "\nERROR: cannot open " << str << " to log Magnum. Please ensure path and write permissions are correct." << endl;
    return false;
  } else {
    fclose(f);
  }
  logFile = str;

  return true;
}

bool MParams::checkMod(mMass m){
  unsigned int i;
  for(i=0;i<params->mods.size();i++){
    if(params->mods[i].index == m.index && params->mods[i].mass == m.mass && params->mods[i].xl == m.xl) return true;
  }
  return false;
}

void MParams::exportDefault(string ver){
  mParams def;
  FILE* f=fopen("magnum_default_params.conf","wt");

  fprintf(f,"# Magnum %s parameter file\n\n",ver.c_str());
  fprintf(f,"# This file was autogenerated. Please alter and rename before use.\n");
  fprintf(f,"# All parameters are separated from their values by an equals sign ('=')\n");
  fprintf(f,"# Anything after a '#' will be ignored for the remainder of the line.\n");
  fprintf(f, "# Remove the '#' at the beginning of a parameter line to activate that parameter.\n");
  fprintf(f, "\n\n#\n# Computational Settings\n#\n");
  fprintf(f, "threads = %d\n",def.threads);
  fprintf(f, "\n\n#\n# Input and Output files - specify full path for input files if not in current working directory\n#\n");
  fprintf(f, "MS_data_file = yourData.mzML            #users specify their data here.\n");
  fprintf(f, "database = SearchDatabase.fasta         #users specify their proteins here.\n");
  fprintf(f, "results_path = .                        #path must exist. Use '.' for current working directory.\n");
  fprintf(f, "export_pepXML = %d                       #0=no, 1=yes\n", (int)def.exportPepXML);
  fprintf(f, "export_percolator = %d                   #0=no, 1=yes\n",(int)def.exportPercolator);
  fprintf(f, "split_percolator = %d                    #0=no, 1=yes\n", (int)def.splitPercolator);
  fprintf(f, "percolator_version = %.2lf\n", def.percVersion);
  fprintf(f, "\n\n#\n# Parameters describing data analyzed by Magnum\n#\n");
  fprintf(f, "instrument = %d            #0=Orbitrap, 1=FTICR\n",def.instrument);
  fprintf(f, "MS1_centroid = %d          #0=no, 1=yes\n",def.ms1Centroid);
  fprintf(f, "MS2_centroid = %d          #0=no, 1=yes\n", def.ms2Centroid);
  fprintf(f, "MS1_resolution = %d    #resolution at 400 m/z, value ignored if data are centroided\n", def.ms1Resolution);
  fprintf(f, "MS2_resolution = %d    #resolution at 400 m/z, value ignored if data are centroided\n", def.ms2Resolution);
  fprintf(f, "\n\n#\n# Amino acid search modification. Use uppercase amino acid letters. n=peptide N-terminus, c=peptide C-terminus\n#\n");
  fprintf(f, "#fixed_modification = C 57.02146       #fixed modifications are applied to all amino acid instances.\n");
  fprintf(f, "#fixed_modification_protN = 15.994915  #fixed modifications to protN are applied to all protein N-termini.\n");
  fprintf(f, "#fixed_modification_protN = 15.994915  #fixed modifications to protC are applied to all protein C-termini.\n");
  fprintf(f, "#modification = M 15.994915           #modifications are possible (differential) mass alterations.\n");
  fprintf(f, "#modification = N 0.984016            #use multiple modification (and fixed_modification) lines for each possible modification mass.\n");
  fprintf(f, "#modification_protN = 42.010565       #modifications to protN are differential on protein N-termini.\n");
  fprintf(f, "#modification_protC = 15.994915       #modifications to protC are differential on protein C-termini.\n");
  fprintf(f, "max_mods_per_peptide = %d              #limit the number of modifications on a peptide (does not include fixed_modifications)\n", def.maxMods);
  fprintf(f, "#aa_mass = X 101.074328               #overwrite the default mass on any amino acid. Useful for adding non-canonical amino acids to your search.\n");
  fprintf(f, "\n\n#\n# Digestion enzyme rules: see http://magnum-ms.org/param/enzyme.html\n#\n");
  fprintf(f, "enzyme = [KR]|{P} Trypsin     #must specify rule, followed by enzyme name.\n");
  fprintf(f, "max_miscleavages = %d          #number of missed enzyme cleavages to allow.\n",def.miscleave);
  fprintf(f, "\n\n#\n# Scoring Algorithm Parameters: specifies resolution and fragment ions to search.\n#\n");
  fprintf(f, "# fragment_bin_offset and fragment_bin_size influence algorithm precision and memory usage.\n");
  fprintf(f, "# They should be set appropriately for the data analyzed.\n");
  fprintf(f, "# For ion trap ms/ms:  1.0005 size, 0.4 offset\n");
  fprintf(f, "# For high res ms/ms:    0.03 size, 0.0 offset\n");
  fprintf(f, "fragment_bin_size = %.2lf      #in m/z units\n",def.binSize);
  fprintf(f, "fragment_bin_offset = %.1lf     #between 0.0 and 1.0\n",def.binOffset);
  fprintf(f, "ion_series_A = %d              #0=do not search, #1=search\n",(int)def.ionSeries[0]);
  fprintf(f, "ion_series_B = %d\n",(int)def.ionSeries[1]);
  fprintf(f, "ion_series_C = %d\n", (int)def.ionSeries[2]);
  fprintf(f, "ion_series_X = %d\n", (int)def.ionSeries[3]);
  fprintf(f, "ion_series_Y = %d\n", (int)def.ionSeries[4]);
  fprintf(f, "ion_series_Z = %d              #Z-dot values are used\n", (int)def.ionSeries[5]);
  fprintf(f, "\n\n#\n# Search Space Prameters: specifies breadth of data analysis.\n#\n");
  fprintf(f, "#adduct_sites = DE         #restricts adduct mass to the specified amino acids. Use 'n' and 'c' for protein termini.\n");
  fprintf(f, "decoy_filter = %s %d    #identifier for all decoys in the database. 0=database has decoys, 1=have Magnum generate decoys\n",def.decoy.c_str(),(int)def.buildDecoy);
  //deprecated:
  //fprintf(f, "e_value_depth = %d       #robustness of e-value histogram. Larger number improves e-value estimates, but increases computation time.\n",def.eValDepth);
  fprintf(f, "min_adduct_mass = %.1lf     #lowest allowed adduct mass in Daltons.\n",def.minAdductMass);
  fprintf(f, "max_adduct_mass = %.1lf    #highest allowed adduct mass in Daltons.\n",def.maxAdductMass);
  fprintf(f, "\nppm_tolerance_pre = %.1lf   #mass tolerance on precursor when searching (in ppm)\n",def.ppmPrecursor);
  fprintf(f, "precursor_refinement = %d   #0 = off, 1 = attempt to correct precursor prediction errors from MS1 scan.\n",(int)def.precursorRefinement);
  fprintf(f, "isotope_error = %d          #search isotope peak offsets. 0=off, 1=one offset, 2=two offsets, 3=three offsets\n",def.isotopeError);
  fprintf(f, "prefer_precursor_pred = %d  #prefer precursor mono mass predicted by instrument software.\n",def.preferPrecursor);
  fprintf(f, "                           #  0 = ignore previous predictions\n");
  fprintf(f, "                           #  1 = use only previous predictions\n");
  fprintf(f, "                           #  2 = supplement predictions with additional analysis\n");
  fprintf(f, "\nspectrum_processing = %d    #0 = no, 1 = collapse MS2 isotope distributions to a single monoisotopic peak.\n",def.specProcess);
  fprintf(f, "min_spectrum_peaks = %d    #minimum peaks in a MS2 scan to be searched.\n",def.minPeaks);
  fprintf(f, "max_spectrum_peaks = %d     #maximum number of MS2 peaks to use during analysis. 0 uses all peaks.\n",def.maxPeaks);
  fprintf(f, "\nmin_peptide_length = %d     #minimum number of amino acids per peptide searched.\n",def.minPepLen);
  fprintf(f, "max_peptide_length = %d    #maximum number of amino acids per peptide searched.\n", def.maxPepLen);
  fprintf(f, "min_peptide_mass = %.1lf   #minimum allowed peptide mass in Daltons.\n", def.minPepMass);
  fprintf(f, "max_peptide_mass = %.1lf  #maximum allowed peptide mass in Daltons.\n", def.maxPepMass);
  fprintf(f, "\natomic_signature = 0       #molecular formula for the unusual atoms only. Case sensitive. 0=off.\n", def.atomSig);
  fprintf(f, "atomic_processing = %d     #defines rules for use only with atomic_signature settings.\n",def.atomicProcessing);
  fprintf(f, "                          # 0 = no special rules.\n");
  fprintf(f, "                          # 1 = prefer atomic signature in precursor monoisotopic mass correction.\n");
  fprintf(f, "                          # 2 = only open mod search when atomic signature found.\n");
  fprintf(f, "\n\n#\n# Reporter Ions\n#\n");
  fprintf(f, "reporter_ion_threshold = %.1lf    #relative MS2 abundance threshold for reporter ions.\n",def.rIonThreshold);
  fprintf(f, "#reporter_ion = 160.04           #list as many MS2 reporter ion m/z values as desired, one per line.\n");
  fprintf(f, "#reporter_ion = 311.00\n");
  fprintf(f, "#reporter_ion = 470.03\n");
  fprintf(f, "\n\n#\n# Diagnostics: Only recommended for advanced users. If enabled, a diagnostic XML file is output with the Magnum results.\n#\n");
  fprintf(f, "#diagnostic = 502        #diagnose intermediate peptide calculations for any scan number.\n");
  fprintf(f, "#diagnostic = 503        #list multiple MS2 scan numbers, one per line.\n");
  fprintf(f, "#diagnostic = -1         #or specify -1 to diagnose all MS2 scans.\n");
  fprintf(f, "top_count = %d            #number of lines of candidate peptides to diagnose per precursor prediction per MS2 scan.\n",def.topCount);
  fprintf(f, "truncate_prot_names = %d  #Shorten protein names to just the first number of characters, 0 = off\n",def.truncate);
  fclose(f);
}

void MParams::logParam(string name, string value){
  CnpxParameter t;
  t.name = name;
  t.value = value;
  if (log != NULL) log->addParameter(t.name + " = " + t.value);
  xmlParams.push_back(t);
}

void MParams::logParam(CnpxParameter& t){
  if (log != NULL) log->addParameter(t.name + " = " + t.value);
  xmlParams.push_back(t);
}


void MParams::parse(const char* cmd) {

  char *tok;
  char c_cmd[4096];
  char param[32];
  char tmpstr[256];

  mMass m;

  string tstr;
  vector<string> values;

  strcpy(c_cmd, cmd);

  //Pre-process entire line to remove characters that should not be read
	//Replace first # with a terminator
	tok=strstr(c_cmd,"#");
	if(tok!=NULL) strncpy(tok,"\0",1);

	//if we have only white space, exit here
	strcpy(tmpstr,c_cmd);
	tok=strtok(tmpstr," \t\n\r");
	if(tok==NULL) return;

	//Check if we have a parameter (has '=' in it) or lots of random text.
	tok=strstr(c_cmd,"=");
  if(tok==NULL) {
    if (log != NULL) log->addParameterWarning("Unknown parameter line in config file: " + string(cmd));
    else printf("Unknown parameter line in config file: %s\n", cmd);
    return;
  }

  //Process parameters
	//Read parameter into param name (before = sign) and value (after = sign)
	tok=strtok(c_cmd," \t=\n\r");
	if(tok==NULL) return;
	strcpy(param,tok);
	tok=strtok(NULL," \t=\n\r");
	if(tok==NULL) {
		warn(param,0);
		return;
  } else {
    while(tok!=NULL){
      tstr=tok;
      values.push_back(tstr);
      tok=strtok(NULL," \t=\n\r");
    }
  }

	//Look up parameter and assign the value
  if (strcmp(param, "aa_mass") == 0){
    m.index = (int)values[0][0];
    m.mass = atof(&values[1][0]);
    if (values.size() > 2 && values[2][0]!='0') m.xl=true;
    else m.xl=false;
    params->aaMass.push_back(m);
    logParam("aa_mass",values[0] + " " + values[1]);

  } else if (strcmp(param, "adduct_sites") == 0) {
    params->adductSites = values[0];
    logParam("adduct_sites", values[0]);

  } else if(strcmp(param,"atomic_processing")==0){
    params->atomicProcessing = atoi(values[0].c_str());
    if (params->atomicProcessing < 0 || params->atomicProcessing>2) {
      params->atomicProcessing = 0;
      warn("atomic_processing value is out of range. Value was reset to default (0).", 4);
    }
    logParam("atomic_processing", values[0]);

  } else if (strcmp(param, "atomic_signature") == 0) {
    if (values[0][0]!='0' && !processAtomicSig(values[0], params->atomSig)) {
      warn("ERROR: bad atomic_signature parameter. Stopping analysis.", 3);
      exit(-5);
    }
    logParam("atomic_signature", values[0]);

	} else if(strcmp(param,"database")==0){
    params->dbFile=values[0];
    logParam("database", values[0]);

  } else if(strcmp(param,"diagnostic")==0){  //a value of -1 means diagnose all spectra, overriding any existing or following spectrum specifications
    if (atoi(&values[0][0])==-1) params->diag.clear();
    params->diag.push_back(atoi(&values[0][0]));
    logParam("diagnostic",values[0]);

	} else if(strcmp(param,"decoy_filter")==0){
    if (values.size() != 2) {
      warn("ERROR: bad decoy_filter parameter. Suspected use of deprecated format.", 3);
      exit(-5);
    }
    params->decoy=values[0];
    if (atoi(values[1].c_str()) == 0) params->buildDecoy = false;
    else params->buildDecoy = true;
    logParam("decoy_filter", values[0] + " " + values[1]);

  } else if(strcmp(param,"enzyme")==0){
    params->enzyme=values[0];
    CnpxParameter xml;
    xml.name = "enzyme";
    xml.value = values[0];
    if (values.size() > 1) {
      params->enzymeName=values[1];
      xml.value+=" " +values[1];
    } else {
      params->enzymeName="Unnamed";
      warn("Using deprecated enzyme paramter format. Enzyme name will be set to \"Unnamed\"", 4);
    }
    logParam(xml);

  } else if (strcmp(param, "e_value_depth") == 0){
    warn("Using deprecated e_value_depth parameter. Value will be ignored.", 4);
    //params->eValDepth = atoi(&values[0][0]);
    //if (params->eValDepth<0 || params->eValDepth>15000){
    //  warn("ERROR: e_value_depth out of range (0-15000). Reverting to default of 3000.", 3);
    //  params->eValDepth = 5000;
    //}
    //logParam("e_value_depth",values[0]);

  } else if(strcmp(param, "export_pepXML")==0 || strcmp(param, "export_pepxml")==0){
    if(atoi(&values[0][0])!=0) params->exportPepXML=true;
    else params->exportPepXML=false;
    logParam("export_pepXML",values[0]);

  } else if(strcmp(param,"export_percolator")==0){
    if(atoi(&values[0][0])!=0) params->exportPercolator=true;
    else params->exportPercolator=false;
    logParam("export_percolator",values[0]);

  } else if(strcmp(param,"fixed_modification")==0){
    m.index=(int)values[0][0];
    m.mass=atof(&values[1][0]);
    if(m.mass!=0) params->fMods.push_back(m);
    logParam("fixed_modification", values[0]+" "+values[1]);

  } else if (strcmp(param, "fixed_modification_protC") == 0){
    m.index = (int)'%';
    m.mass = atof(&values[0][0]);
    if (m.mass != 0) params->fMods.push_back(m);
    logParam("fixed_modification_protC",values[0]);

  } else if (strcmp(param, "fixed_modification_protN") == 0){
    m.index = (int)'$';
    m.mass = atof(&values[0][0]);
    if (m.mass != 0) params->fMods.push_back(m);
    logParam("fixed_modification_protN",values[0]);

	} else if(strcmp(param,"fragment_bin_offset")==0){
    double d= atof(&values[0][0]);
    if(d<0 || d>1){
      warn("ERROR: Invalid value for fragment_bin_offset parameter. Range = 0.0 - 1.0; Stopping analysis.", 3);
      exit(-5);
    }
    params->binOffset=1.0-d;
    logParam("fragment_bin_offset",values[0]);

	} else if(strcmp(param,"fragment_bin_size")==0){
    params->binSize=atof(&values[0][0]);
    if(params->binSize<=0){
      warn("ERROR: Invalid value for fragment_bin_size parameter. Stopping analysis.",3);
      exit(-5);
    }
    logParam("fragment_bin_size",values[0]);

	} else if(strcmp(param,"instrument")==0){
    params->instrument=atoi(&values[0][0]);
    if(params->instrument<0 || params->instrument>1){
      warn("ERROR: instrument value out of range for instrument. Stopping analysis.",3);
      exit(-5);
    }
    logParam("instrument",values[0]);

  } else if(strcmp(param,"ion_series_A")==0){
    if(atoi(&values[0][0])==0) params->ionSeries[0]=false;
    else params->ionSeries[0]=true;
    logParam("ion_series_A",values[0]);

  } else if(strcmp(param,"ion_series_B")==0){
    if(atoi(&values[0][0])==0) params->ionSeries[1]=false;
    else params->ionSeries[1]=true;
    logParam("ion_series_B",values[0]);

  } else if(strcmp(param,"ion_series_C")==0){
    if(atoi(&values[0][0])==0) params->ionSeries[2]=false;
    else params->ionSeries[2]=true;
    logParam("ion_series_C",values[0]);

  } else if(strcmp(param,"ion_series_X")==0){
    if(atoi(&values[0][0])==0) params->ionSeries[3]=false;
    else params->ionSeries[3]=true;
    logParam("ion_series_X",values[0]);

  } else if(strcmp(param,"ion_series_Y")==0){
    if(atoi(&values[0][0])==0) params->ionSeries[4]=false;
    else params->ionSeries[4]=true;
    logParam("ion_series_Y",values[0]);

  } else if(strcmp(param,"ion_series_Z")==0){
    if(atoi(&values[0][0])==0) params->ionSeries[5]=false;
    else params->ionSeries[5]=true;
    logParam("ion_series_Z",values[0]);

  } else if (strcmp(param, "isotope_error")==0){
    params->isotopeError = atoi(&values[0][0]);
    if (params->isotopeError < 0 || params->isotopeError>3){
      warn("ERROR: isotope_error has invalid value. Stopping analysis.",3);
      exit(-5);
    }
    logParam("isotope_error",values[0]);
  
  } else if (strcmp(param, "max_adduct_mass") == 0){
    params->maxAdductMass = atof(&values[0][0]);
    logParam("max_adduct_mass",values[0]);

	} else if(strcmp(param,"max_miscleavages")==0){
    params->miscleave=atoi(&values[0][0]);
    logParam("max_miscleavages",values[0]);

  } else if(strcmp(param,"max_mods_per_peptide")==0){
    params->maxMods=atoi(&values[0][0]);
    logParam("max_mods_per_peptide",values[0]);

  } else if (strcmp(param, "max_peptide_length") == 0){
    params->maxPepLen = atoi(&values[0][0]);
    if (params->maxPepLen>70){
      warn("ERROR: max_peptide_length exceeds limit. Capping at to 70.", 3);
      params->rIonThreshold = 70;
    }
    logParam("max_peptide_length",values[0]);

	} else if(strcmp(param,"max_peptide_mass")==0){
    params->maxPepMass=atof(&values[0][0]);
    logParam("max_peptide_mass",values[0]);

  } else if(strcmp(param,"max_spectrum_peaks")==0){
    params->maxPeaks=atoi(&values[0][0]);
    logParam("max_spectrum_peaks",values[0]);

  } else if (strcmp(param, "min_adduct_mass") == 0){
    params->minAdductMass = atof(&values[0][0]);
    logParam("min_adduct_mass",values[0]);

  } else if (strcmp(param, "min_peptide_length") == 0){
    params->minPepLen = atoi(&values[0][0]);
    logParam("min_peptide_length",values[0]);

	} else if(strcmp(param,"min_peptide_mass")==0){
    params->minPepMass=atof(&values[0][0]);
    logParam("min_peptide_mass",values[0]);

  } else if (strcmp(param, "min_spectrum_peaks") == 0){
    params->minPeaks = atoi(&values[0][0]);
    logParam("min_spectrum_peaks",values[0]);

  } else if(strcmp(param,"modification")==0){
    m.xl=false;
    m.index=(int)values[0][0];
    m.mass=atof(&values[1][0]);
    if(m.mass!=0 && !checkMod(m)) params->mods.push_back(m);
    logParam("modification",values[0]+" "+values[1]);

  } else if (strcmp(param, "modification_protC") == 0){
    m.xl = false;
    m.index = (int)'%';
    m.mass = atof(&values[0][0]);
    if (m.mass!=0) { //acceptable to use placeholder; don't load it as a parameter
      if (!checkMod(m)) params->mods.push_back(m);
    }
    logParam("modification_protC",values[0]);

  } else if (strcmp(param, "modification_protN") == 0){
    m.xl = false;
    m.index = (int)'$';
    m.mass = atof(&values[0][0]);
    if(m.mass != 0) { //acceptable to use placeholder; don't load it as a parameter
      if (!checkMod(m)) params->mods.push_back(m);
    }
    logParam("modification_protN",values[0]);

	} else if(strcmp(param,"MS_data_file")==0){
    params->msFile=values[0];
    logParam("MS_data_file",values[0]);

  } else if(strcmp(param,"MS1_centroid")==0){
    params->ms1Centroid=atoi(&values[0][0]);
    logParam("MS1_centroid",values[0]);

  } else if(strcmp(param,"MS2_centroid")==0){
    params->ms2Centroid=atoi(&values[0][0]);
    logParam("MS2_centroid",values[0]);

	} else if(strcmp(param,"MS1_resolution")==0){
    params->ms1Resolution=atoi(&values[0][0]);
    logParam("MS1_resolution", values[0]);

	} else if(strcmp(param,"MS2_resolution")==0){
		params->ms2Resolution=atoi(&values[0][0]);
    logParam("MS2_resolution",values[0]);

  } else if(strcmp(param,"percolator_version")==0){
    params->percVersion=atof(&values[0][0]);
    logParam("percolator_version",values[0]);

	} else if(strcmp(param,"ppm_tolerance_pre")==0){
    params->ppmPrecursor=atof(&values[0][0]);
    logParam("ppm_tolerance_pre",values[0]);

  } else if (strcmp(param, "precursor_refinement") == 0){
    if (atoi(&values[0][0]) == 0) params->precursorRefinement = false;
    else params->precursorRefinement = true;
    logParam("precursor_refinement",values[0]);

  } else if(strcmp(param,"prefer_precursor_pred")==0){
    params->preferPrecursor=atoi(&values[0][0]);
    logParam("prefer_precursor_pred",values[0]);

  } else if (strcmp(param, "reporter_ion") == 0){
    if (atof(&values[0][0])>0)  params->rIons.push_back(atof(&values[0][0]));
    else  warn("ERROR: reporter_ion has invalid value. Skipping parameter.", 3);
    logParam("reporter_ion",values[0]);

  } else if (strcmp(param, "reporter_ion_threshold") == 0){
    params->rIonThreshold=atof(&values[0][0]);
    if(params->rIonThreshold<0 || params->rIonThreshold>100){
      warn("ERROR: reporter_ion_threshold has invalid value. Defaulting to 10.", 3);
      params->rIonThreshold=10;
    }
    logParam("reporter_ion_threshold",values[0]);

  } else if (strcmp(param, "results_path") == 0){
    params->resPath=values[0];
    logParam("results_path",values[0]);

  } else if(strcmp(param,"spectrum_processing")==0) {
    params->specProcess=atoi(&values[0][0]);
    logParam("spectrum_processing",values[0]);

  } else if (strcmp(param, "split_percolator") == 0){
    if (atoi(&values[0][0]) != 0) params->splitPercolator = true;
    else params->splitPercolator = false;
    logParam("split_percolator", values[0]);

  } else if(strcmp(param,"threads")==0) {
    params->threads = atoi(&values[0][0]);
    int iCores;
#ifdef _WIN32
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    iCores = sysinfo.dwNumberOfProcessors;
#else
    iCores = sysconf(_SC_NPROCESSORS_ONLN);
#endif
    if (params->threads == 0){
      params->threads = iCores;
      char tst[8];
      sprintf(tst, "%d", iCores);
      string ts = "Setting number of threads from 0 to maximum of ";
      ts += tst;
      warn(ts, 4);
    } else if (params->threads<0) {
      params->threads += iCores;
      if (params->threads<1) {
        warn("Net number of threads is less than 1. Forcing thread value of 1.", 4);
        params->threads = 1;
      } else {
        char tst[12];
        sprintf(tst, "%d", params->threads);
        string ts = "Adjusting number of threads to ";
        ts+=tst;
        ts+=" out of ";
        sprintf(tst, "%d", iCores);
        ts += tst;
        ts += " max cores.";
        warn(ts, 4);
      }
    } else if (params->threads>iCores) {
      warn("Requested threads exceeds number of CPU cores. Performance may be degraded.", 4);
    }
    logParam("threads",values[0]);

  } else if(strcmp(param,"top_count")==0) {
    params->topCount=atoi(&values[0][0]);
    if(params->topCount>50) {
      warn("WARNING: top_count is larger than expected. An appropriate value is likely between 5 and 50.",3);
    }
    if (params->topCount<1){
      warn("ERROR: top_count must be greater than zero. Stopping Magnum.", 4);
      params->topCount=1;
    }
    logParam("top_count",values[0]);

  } else if(strcmp(param,"truncate_prot_names")==0) {
    params->truncate=atoi(&values[0][0]);
    logParam("truncate_prot_names",values[0]);

	} else {
		warn(param,1);
	}

}

void MParams::setLog(MLog* c){
  log = c;
}

void MParams::setParams(mParams* p){
  params = p;
}

void MParams::warn(const char* c, int i){
	switch(i){
  case 0:
    if (log != NULL) log->addParameterWarning("Parameter " + string(c) + " has no value.");
    else printf("  WARNING: Parameter %s has no value.", c);
    break;
  case 1:
    if (log != NULL) log->addParameterWarning("Unknown parameter: " + string(c));
    else printf("  WARNING:  %s\n", c);
    break;
  case 2:
    if (log != NULL) log->addParameterWarning("Parameter " + string(c) + "has been deprecated and will be ignored.");
    else printf("  WARNING: Parameter %s has been deprecated and will be ignored.\n", c);
    break;
  case 3:
    if (log != NULL) log->addError(string(c));
    else printf("  %s\n", c);
    break;
  case 4:
    if (log != NULL) log->addParameterWarning(string(c));
    else printf("  WARNING: %s\n", c);
    break;
  default:
    if (log != NULL) log->addParameterWarning(string(c));
    else printf("  %s\n", c);
    break;
	}
}

void MParams::warn(string c, int i){
  warn(c.c_str(), i);
}

//For customized Hardklor analysis
bool MParams::processAtomicSig(string sig, vector<mAtom>& v) {
  //build periodic table that maps element symbols to Hardklor periodic table array positions
  map<string, int> pt;
  pt.insert(pair<string, int>("H", 1));
  pt.insert(pair<string, int>("He", 2));
  pt.insert(pair<string, int>("Li", 3));
  pt.insert(pair<string, int>("Be", 4));
  pt.insert(pair<string, int>("B", 5));
  pt.insert(pair<string, int>("C", 6));
  pt.insert(pair<string, int>("N", 7));
  pt.insert(pair<string, int>("O", 8));
  pt.insert(pair<string, int>("F", 9));
  pt.insert(pair<string, int>("Ne", 10));
  pt.insert(pair<string, int>("Na", 11));
  pt.insert(pair<string, int>("Mg", 12));
  pt.insert(pair<string, int>("Al", 13));
  pt.insert(pair<string, int>("Si", 14));
  pt.insert(pair<string, int>("P", 15));
  pt.insert(pair<string, int>("S", 16));
  pt.insert(pair<string, int>("Cl", 17));
  pt.insert(pair<string, int>("Ar", 18));
  pt.insert(pair<string, int>("K", 19));
  pt.insert(pair<string, int>("Ca", 20));
  pt.insert(pair<string, int>("Sc", 21));
  pt.insert(pair<string, int>("Ti", 22));
  pt.insert(pair<string, int>("V", 23));
  pt.insert(pair<string, int>("Cr", 24));
  pt.insert(pair<string, int>("Mn", 25));
  pt.insert(pair<string, int>("Fe", 26));
  pt.insert(pair<string, int>("Co", 27));
  pt.insert(pair<string, int>("Ni", 28));
  pt.insert(pair<string, int>("Cu", 29));
  pt.insert(pair<string, int>("Zn", 30));
  pt.insert(pair<string, int>("Ga", 31));
  pt.insert(pair<string, int>("Ge", 32));
  pt.insert(pair<string, int>("As", 33));
  pt.insert(pair<string, int>("Se", 34));
  pt.insert(pair<string, int>("Br", 35));
  pt.insert(pair<string, int>("Kr", 36));

  v.clear();

  //process string
  string atom;
  string count;
  for (size_t a = 0;a < sig.size();a++) {
    if (isalpha(sig[a])) {
      if (sig[a] < 91) { //new capital letter means we have a new atom
        if (!atom.empty()) { //process other atom
          map<string, int>::iterator it = pt.find(atom);
          if (it == pt.end()) {
            cout << "Incorrect or unsupported atom: " << atom << endl;
            return false;
          }

          mAtom at;
          at.index = it->second; 
          if (count.empty()) at.count = 1;
          else at.count = atoi(count.c_str());
          v.push_back(at);

          atom.clear();
          atom += sig[a];
          count.clear();
        } else {
          atom += sig[a];
          count.clear();
        }
      } else {
        atom += sig[a];
      }
    } else if (sig[a] > 47 && sig[a] < 58) {
      count += sig[a];
    } else {
      cout << "Unknown atomic signature character: " << sig[a] << endl;
      return false;
    }
  }

  if (!atom.empty()) {
    map<string, int>::iterator it = pt.find(atom);
    if (it == pt.end()) {
      cout << "Incorrect or unsupported atom: " << atom << endl;
      return false;
    }

    mAtom at;
    at.index = it->second;
    if (count.empty()) at.count = 1;
    else at.count = atoi(count.c_str());
    v.push_back(at);
  }

  return true;
}

//Takes relative path and finds absolute path
bool MParams::processPath(const char* cwd, const char* in_path, char* out_path){
  //if windows or unix in_path, just copy it to out_path
  if (strlen(in_path) > 0 && in_path[0] == '/'){ //unix
    strcpy(out_path, in_path);
    return true;
  }
  if (strlen(in_path) > 1 && in_path[1] == ':'){ //windows
    strcpy(out_path, in_path);
    return true;
  }

  //tokenize cwd
  char* tok;
  char str[1024];
  strcpy(str, cwd);
  string s;
  vector<string> v;

  tok = strtok(str, "\\/\n\r");
  while (tok != NULL){
    s = tok;
    v.push_back(s);
    tok = strtok(NULL, "\\/\n\r");
  }

  //tokenize in_path
  strcpy(str, in_path);

  tok = strtok(str, "\\/\n\r");
  while (tok != NULL){
    if (strcmp(tok, "..") == 0) {
      v.pop_back();
    } else if (strcmp(tok, ".") == 0){
      //do nothing
    } else {
      s = tok;
      v.push_back(s);
    }
    tok = strtok(NULL, "\\/\n\r");
  }

  //build absolute path
#ifdef _MSC_VER
  s.clear();
#else
  s.clear();
  s += slashdir;
#endif
  for (size_t i = 0; i < v.size(); i++){
    s += v[i];
    s += slashdir;
  }
  s[s.size() - 1] = '\0';
  strcpy(out_path, &s[0]);
  return true;

}

//Takes relative path and finds absolute path
void MParams::trimPath(string in, string& path, string& fname){
  size_t i = in.find_last_of("/\\");
  if (i != string::npos) {
    fname = in.substr(i + 1);
    path = in.substr(0, i);
  } else {
    fname=in;
    path.clear();
  }
}
